# 算法

1. 一般来说这些算法接受的都是迭代器的对象
2. 一般需要原始容器的头尾，需要提供目标容器的头部，
3. 如果不是拷贝操作以外，如果要做类似拷贝的操作的话，还需要提前给目标容器提前分配好内存空间
4. 一般的算法都提供普通和条件两种，普通的需要自己重写“==”操作，条件的话需要写仿函数

## 遍历算法

1. for_each
2. transfrom 这个是一个搬运工具，前两个是被搬运的迭代器首尾位置，第三个是搬运地的位置（要提前用 resize 设置好大小，不小于原始的），还有一个参数是对原来的容器里面的参数的操作的函数，也可以是仿函数。

## 查找算法

这里面的查找的条件，都可以用仿函数的一元谓词来表示。

1. find 这个是直接进行值的比较，非常的不好用，如果比较自定义的类的话还要自己重载类的“==”的算法。
2. find_if 这个可以提供一个函数用于判断是否符合条件，相对好用一些。
3. adjacent_find 这个查找相邻的重复元素，和 find 一样，如果是自定义的类的话也要重载相同的算法。
4. binary_search 这个用于判断是否存在，返回 true 或者 false（这个必须是有序序列才可以使用）。
5. count 统计元素出现的次数
6. count_if 统计符合条件的元素出现的次数。

## 排序算法

1. sort 前两个参数指定起始范围，最后一个是一个二元谓词，用于制定比较两个元素的方法。
2. random_shuffle 这是一个洗牌算法，用于把指定区间范围内的元素打乱，然后随机排列。（要加一个随机数种子效果会更好）
3. merge 合并排序，这个先提供两个原始的容器，然后再提供一个新的提前 resize 好大小的容器，之后把前两个的内容排序好以后添加到新的容器。
4. reverse 反转容器内元素的算法

## 拷贝和替换算法

1. copy 这个先提供原始容器的起始位置，然后提供目标容器的头部，就会做拷贝的操作
2. replace 这个是把容器指定的旧值替换成新值
3. replace_if 这个用于把容器里面符合条件的元素替换成新值
4. swap 交换两个容器的元素

## 算术生成算法（numeric）

1. accumulate 累加所有的值，可以提供一个初值
2. fill 填充指定区间内的内容为指定的值

## 集合运算

1. set_intersection 求两个容器的交集，赋值给一个新的容器（这个在迭代的时候，要使用返回的迭代器的值，否则可能会因大小不匹配打出多余的内容）
2. set_union 求两个容器的并集，操作和 1 类似
3. set_difference 求两个容器的差集
